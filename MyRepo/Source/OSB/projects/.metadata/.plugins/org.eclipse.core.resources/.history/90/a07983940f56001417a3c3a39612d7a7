package com.acs.ivr.benefits.access.webservice;

import java.io.StringWriter;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ResourceBundle;
import java.util.StringTokenizer;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.sql.DataSource;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import oracle.jdbc.OracleTypes;

import org.apache.log4j.Logger;
import org.apache.xmlbeans.XmlException;
import org.apache.xmlbeans.XmlObject;
import org.apache.xmlbeans.XmlOptions;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

import com.acs.ivr.benefits.access.beans.CallableStmtArg;
import com.acs.ivr.benefits.access.beans.DataAccessInputs;
import com.acs.ivr.benefits.access.util.DOMUtil;
import com.acs.ivr.benefits.access.util.JDBCUtil;
import com.acshrsolutions.ivr.daws.InputsDocument;

public class DataAccessService {
	private static Logger logger = Logger.getLogger(DataAccessService.class);

	private static ResourceBundle resource = ResourceBundle
			.getBundle("com.acs.ivr.benefits.access.nls."
					+ System.getProperty("data.access.env","dev"));
	
	

	/*public DataAccessService() {

		CommonUtil.log4jLoader();

	}
*/
	/**
     *
     */
	public Document getResults(String xmlDoc) {
		
		logger.info(" Enter in DataAccessService :: getResults processing started");
		return (getResults(getInputsXMLBean(xmlDoc)));
		
	}

	/**
     *
     */
	public Document getResults(DataAccessInputs inputs) {
		
		
		if (inputs == null)
			return (null);

		Document doc = null;
		Connection conn = null;
		CallableStatement stmt = null;

		try {

			Hashtable<String, String> ht = new Hashtable<String, String>(7);

			ht.put(Context.INITIAL_CONTEXT_FACTORY,
					"weblogic.jndi.WLInitialContextFactory");

			InitialContext initContext = new InitialContext(ht);
			DataSource ds = (DataSource) initContext.lookup("jdbc/"
					+ inputs.getDataSource().toUpperCase());
			conn = ds.getConnection();

			stmt = conn.prepareCall(JDBCUtil.prepareCallableStatement(inputs));			
			
			JDBCUtil.processArguments(inputs, stmt);

			doc = JDBCUtil.toDocument(inputs, stmt);
		} catch (Exception e) {
			logger.error("Exception occurred in getResults:", e);
		} finally {
			try {
				if (stmt != null)
					stmt.close();				
				if (conn != null)

					conn.close();
				conn = null;				
			} catch (SQLException e) {
			}
		}

		if (logger.isDebugEnabled() && doc != null) {
			try {
				Transformer transformer = (TransformerFactory.newInstance())
						.newTransformer();
				transformer.setOutputProperty(OutputKeys.INDENT, "yes");
				transformer.setOutputProperty(
						"{http://xml.apache.org/xslt}indent-amount", "4");
				StringWriter sw = new StringWriter();
				StreamResult result = new StreamResult(sw);
				transformer.transform(new DOMSource(doc), result);

				logger.debug("Results: " + sw.toString());
			} catch (Exception e) {
				System.out.println("getClientData Error: " + e.toString());
				e.printStackTrace();
			}
		}
		logger.info("Exit from DataAccessService :: getResults processing ended");
		return doc;
	}

	public Document getClientData(String clientCode) {
		logger.info(" Enter in DataAccessService :: getClientData processing started");
		if (clientCode == null)
			return (null);

		logger.debug("getClientData: " + clientCode);

		Document doc = null;
		Connection conn = null;
		CallableStatement stmt = null;

		String serverColumn = resource.getString("serverColumn");
		String resultColumns[] = { "db_name", "comp_name", serverColumn };

		DataAccessInputs inputs = new DataAccessInputs();
		inputs.setDataSource(resource.getString("dataSources"));
		inputs.setStoredProc("KL_SP..duo_get_companyDB");
		inputs.setReturnCode(true);
		inputs.addCallableArg(new CallableStmtArg(1, "OUT", "ReturnCode", null,
				java.sql.Types.INTEGER, 0));
		inputs.addCallableArg(new CallableStmtArg(2, "IN", "comp_nr",
				clientCode, java.sql.Types.VARCHAR, 0));
		inputs.addCallableArg(new CallableStmtArg(3, "INOUT", "Error_Msg",
				null, java.sql.Types.VARCHAR, 0));

		try {
			InitialContext initContext = new InitialContext();
			StringTokenizer strTok = new StringTokenizer(
					inputs.getDataSource(), ",");
			while (strTok.hasMoreTokens()) {
				String token = strTok.nextToken();
				// logger.debug( "DataSource: " + token );
				try {
					DataSource ds = (DataSource) initContext.lookup("jdbc/"
							+ token);
					conn = ds.getConnection();
					break;
				} catch (Exception e) {
					continue;
				}
			} // while

			stmt = conn.prepareCall(JDBCUtil.prepareCallableStatement(inputs));
			JDBCUtil.processArguments(inputs, stmt);

			doc = JDBCUtil.toDocument(inputs, stmt);

			// Remove and update columns
			Node resultSetMetaData = DOMUtil.getChild(doc,
					"daws:ResultSetMetaData", true);
			((Element) resultSetMetaData).setAttribute("ColumnCount",
					String.valueOf(resultColumns.length));

			List columnMetaData = DOMUtil.getChildren(resultSetMetaData,
					"daws:ColumnMetaData");
			for (Iterator i = columnMetaData.iterator(); i.hasNext();) {
				Node node = (Node) i.next();
				String name = DOMUtil.getAttribute(node, "ColumnLabel");

				// logger.debug( "ColumnLabel: " + name );
				if (!keepColumn(resultColumns, name)) {
					// logger.debug( "remove ColumnLabel: " + name );
					resultSetMetaData.removeChild(node);
					continue;
				}

				if (serverColumn.equals(name)) {
					// logger.debug( "update ColumnLabel att: " + name );
					((Element) node).setAttribute("ColumnLabel", "Datasource");
				}

				if ("db_name".equals(name)) {
					((Element) node).setAttribute("ColumnLabel", "Database");
				}

				if ("comp_name".equals(name)) {
					((Element) node).setAttribute("ColumnLabel", "CompanyName");
				}
			}

			Node row = DOMUtil.getChild(doc, "daws:Row", true);
			List columns = DOMUtil.getChildren(row, "daws:Column");

			for (Iterator i = columns.iterator(); i.hasNext();) {
				Node node = (Node) i.next();
				String name = DOMUtil.getAttribute(node, "name");

				// logger.debug( "Column: " + name );
				if (!keepColumn(resultColumns, name)) {
					// logger.debug( "remove Column: " + name );
					row.removeChild(node);
					continue;
				}

				if (serverColumn.equals(name)) {
					// logger.debug( "update Column att: " + name );
					((Element) node).setAttribute("name", "Datasource");
				}

				if ("db_name".equals(name)) {
					((Element) node).setAttribute("name", "Database");
				}

				if ("comp_name".equals(name)) {
					((Element) node).setAttribute("name", "CompanyName");
				}
			}
		} catch (Exception e) {
			logger.error("Exception occurred in getClientData:", e);
		} finally {
			try {
				if (stmt != null)
					stmt.close();
				if (conn != null)
					conn.close();
			} catch (SQLException e) {
			}
		}

		if (logger.isDebugEnabled() && doc != null) {
			try {
				Transformer transformer = (TransformerFactory.newInstance())
						.newTransformer();
				transformer.setOutputProperty(OutputKeys.INDENT, "yes");
				transformer.setOutputProperty(
						"{http://xml.apache.org/xslt}indent-amount", "4");
				StringWriter sw = new StringWriter();
				StreamResult result = new StreamResult(sw);
				transformer.transform(new DOMSource(doc), result);
				// transformer.transform( new DOMSource( doc ), new
				// StreamResult( "../logs/clientdata.xml" ) );
				logger.debug("getClientData Results: " + sw.toString());
			} catch (Exception e) {
				System.out.println("getClientData Error: " + e.toString());
				e.printStackTrace();
			}
		}
		logger.info(" Exit from DataAccessService :: getClientData processing ended");
		return doc;
	}

	public Document getErrors(String e) throws Exception {
		Document doc = JDBCUtil.getResultsDoc();
		Element resultsElement = JDBCUtil.getResultsElement(doc);

		Element errorElement = doc.createElement("daws:Errors");
		errorElement.setAttribute("code", "1");
		errorElement.appendChild(doc.createTextNode(e));
		resultsElement.appendChild(errorElement);

		return (doc);
	}

	public Document getErrors(Exception e) throws Exception {
		Document doc = JDBCUtil.getResultsDoc();
		Element resultsElement = JDBCUtil.getResultsElement(doc);

		Element errorElement = doc.createElement("daws:Errors");
		errorElement.setAttribute("code", "1");
		errorElement.appendChild(doc.createTextNode(e.getMessage()));
		resultsElement.appendChild(errorElement);

		return (doc);
	}

	private boolean keepColumn(String[] resultColumns, String name) {
		boolean keepColumn = false;
		for (int ii = 0; ii < resultColumns.length; ii++) {
			// logger.debug( "ii: " + ii +" resultColumns: "+resultColumns[ii]);
			if (resultColumns[ii].equals(name)) {
				keepColumn = true;
				break;
			}
		}
		return (keepColumn);
	}

	public DataAccessInputs getInputs(String xmlDoc) {
		Document doc = null;
		try {
			doc = DOMUtil.xml4jParse(xmlDoc);
		} catch (Exception exe) {
			logger.error("Exception occurred in getInputs:", exe);
		}

		return (getInputs(doc));
	}

	public DataAccessInputs getInputs(InputSource in) {
		Document doc = null;
		try {
			doc = DOMUtil.xml4jParse(in);
		} catch (Exception exe) {
			logger.error("Exception occurred in getInputs:", exe);
		}

		return (getInputs(doc));
	}

	/*
	 * XMLBeans
	 */
	public XmlObject parseXml(String xmlAsString, XmlOptions validationOptions) {

		XmlObject xml = null;
		try {

			xml = XmlObject.Factory.parse(xmlAsString, validationOptions);
			System.out.println("parseXml method : " + xml);
		} catch (XmlException e) {
			logger.error("parseXml:", e);
			System.out.println("parseXml:" + e);
		}
		return xml;
	}

	public DataAccessInputs getInputsXMLBean(String xml) {
		if (xml == null)
			return (null);

		System.out.println("Input XML: " + xml);

		logger.debug("Input XML: " + xml);

		DataAccessInputs inputs = null;

		try {
			ArrayList validationErrors = new ArrayList();
			XmlOptions validationOptions = new XmlOptions();
			validationOptions.setErrorListener(validationErrors);

			// Bind the instance to the generated XMLBeans types.
			System.out.println("Debug point1:");

			InputsDocument inputDoc = (InputsDocument) parseXml(xml, null);

			System.out.println("Debug point1: " + inputDoc);

			if (inputDoc == null)
				return (null);

			boolean isValid = inputDoc.validate(validationOptions);

			if (!isValid) {
				printErrors(validationErrors);
				return (null);
			}

			System.out.println("inputDoc.getInputs(): " + inputDoc.getInputs());

			com.acshrsolutions.ivr.daws.InputsDocument.Inputs xmlInputs = inputDoc
					.getInputs();

			if (xmlInputs.getDataSource() == null
					|| xmlInputs.getDataSource().equals(""))
				throw new Exception("DataSource Missing");

			inputs = new DataAccessInputs();

			inputs.setDataSource(xmlInputs.getDataSource());

			if (xmlInputs.isSetReturnCode())
				inputs.setReturnCode("Y".equals(EnumYesNoToString(xmlInputs
						.getReturnCode().intValue())));

			boolean addResultSetOutput = false;
			if (xmlInputs.isSetOracle()) {
				inputs.setOracleCall("Y".equals(xmlInputs.getOracle()
						.getStringValue()));
				addResultSetOutput = "Y".equals(EnumYesNoToString(xmlInputs
						.getOracle().getAddResultSetOutput().intValue()));
			}

			if (xmlInputs.getDatabase() != null
					&& xmlInputs.getProcedure() != null) {
				inputs.setStoredProc(xmlInputs.getDatabase(),
						xmlInputs.getProcedure());
			} else if (xmlInputs.getSP() != null)
				inputs.setStoredProc(xmlInputs.getSP());

			int argIndex = 1;
			if (inputs.isReturnCode()) {
				inputs.addCallableArg(new CallableStmtArg(argIndex++, "OUT",
						"ReturnCode", null, java.sql.Types.INTEGER, 0));
			}

			com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg[] args = xmlInputs
					.getArgArray();
			for (int i = 0; i < args.length; i++) {
				String jdbcType = EnumJdbcTypeToString(args[i].getJdbcType()
						.intValue());
				inputs.addCallableArg(new CallableStmtArg(argIndex++,
						EnumTypeToString(args[i].getType().intValue()), args[i]
								.getName(), args[i].getStringValue(), jdbcType,
						(jdbcType.equals("decimal")) ? 20 : 0));
			}

			// Add "ResultSet" output. For Oracle cursors.
			if (addResultSetOutput) {
				inputs.addCallableArg(new CallableStmtArg(argIndex++, "OUT",
						"ResultSet", null, OracleTypes.CURSOR, 0));
			}

			// logger.debug( inputs.toString() );
		} catch (Exception exe) {
			logger.error("Exception occurred in getInputsXMLBean:", exe);
			System.out.println("Exception occurred in getInputsXMLBean:" + exe);
		}

		return (inputs);
	}

	public static String EnumYesNoToString(int type) {
		switch (type) {
		case com.acshrsolutions.ivr.daws.YesNo.INT_Y:
			return ("Y");
		case com.acshrsolutions.ivr.daws.YesNo.INT_N:
			return ("N");
		default:
			return ("N");
		}
	}

	public static String EnumTypeToString(int type) {
		switch (type) {
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.Type.INT_IN:
			return ("IN");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.Type.INT_INOUT:
			return ("INOUT");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.Type.INT_OUT:
			return ("OUT");
		default:
			return ("IN");
		}
	}

	public static String EnumJdbcTypeToString(int type) {
		switch (type) {
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_STRING:
			return ("string");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_INTEGER:
			return ("integer");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_FLOAT:
			return ("float");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_DOUBLE:
			return ("double");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_DECIMAL:
			return ("decimal");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_BOOLEAN:
			return ("boolean");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_TIME:
			return ("time");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_DATE:
			return ("date");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_DATETIME:
			return ("datetime");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_BYTE:
			return ("byte");
		case com.acshrsolutions.ivr.daws.InputsDocument.Inputs.Arg.JdbcType.INT_CURSOR:
			return ("cursor");
		default:
			return ("string");
		}
	}

	public void printErrors(ArrayList validationErrors) {
		System.out.println("Errors discovered during validation: \n");
		logger.error("Errors discovered during validation: \n");
		Iterator iter = validationErrors.iterator();
		while (iter.hasNext()) {
			logger.error(">> " + iter.next() + "\n");
		}
	}

	public DataAccessInputs getInputs(Document doc) {
		DataAccessInputs inputs = null;

		if (doc == null)
			return (inputs);

		try {
			Node root = DOMUtil.getChild(doc, "daws:Inputs");

			if (root == null)
				return (inputs);

			// logger.debug( "Root element of the doc is " + root.getNodeName()
			// );

			Node nodeDataSource = DOMUtil.getChild(root, "daws:DataSource");
			if (nodeDataSource == null)
				throw new Exception("DataSource Missing");

			Node nodeDatabase = DOMUtil.getChild(root, "daws:Database");
			Node nodeProcedure = DOMUtil.getChild(root, "daws:Procedure");
			Node nodeSP = DOMUtil.getChild(root, "daws:SP"); // Database &
																// Procedure
			if ((nodeDatabase == null && nodeProcedure == null)
					&& nodeSP == null)
				throw new Exception("Database and/or Stored Procedure Missing");

			Node nodeReturnCode = DOMUtil.getChild(root, "daws:ReturnCode");
			Node nodeOracle = DOMUtil.getChild(root, "daws:Oracle");

			inputs = new DataAccessInputs();

			inputs.setDataSource(DOMUtil.getTextValue(nodeDataSource));

			if (nodeReturnCode != null)
				inputs.setReturnCode("Y".equals(DOMUtil
						.getTextValue(nodeReturnCode)));

			boolean addResultSetOutput = false;
			if (nodeOracle != null) {
				inputs.setOracleCall("Y".equals(DOMUtil
						.getTextValue(nodeOracle)));
				addResultSetOutput = "Y".equals(DOMUtil.getAttribute(
						nodeOracle, "addResultSetOutput"));
			}

			if (nodeDatabase != null && nodeProcedure != null) {
				inputs.setStoredProc(DOMUtil.getTextValue(nodeDatabase),
						DOMUtil.getTextValue(nodeProcedure));
			} else if (nodeSP != null)
				inputs.setStoredProc(DOMUtil.getTextValue(nodeSP));
			else
				throw new Exception("Database and/or Stored Procedure Missing");

			int argIndex = 1;
			if (inputs.isReturnCode()) {
				inputs.addCallableArg(new CallableStmtArg(argIndex++, "OUT",
						"ReturnCode", null, java.sql.Types.INTEGER, 0));
			}

			List args = DOMUtil.getChildren(root, "daws:Arg");
			for (Iterator i = args.iterator(); i.hasNext();) {
				Node node = (Node) i.next();
				String jdbcType = DOMUtil.getAttribute(node, "jdbcType");
				String scale = DOMUtil.getAttribute(node, "scale");
				inputs.addCallableArg(new CallableStmtArg(argIndex++, DOMUtil
						.getAttribute(node, "type"), DOMUtil.getAttribute(node,
						"name"), DOMUtil.getTextValue(node), jdbcType,
						(scale != null) ? Integer.parseInt(scale) : (jdbcType
								.equals("decimal")) ? 20 : 0));
			}

			// Add "ResultSet" output. For Oracle cursors.
			if (addResultSetOutput) {
				inputs.addCallableArg(new CallableStmtArg(argIndex++, "OUT",
						"ResultSet", null, OracleTypes.CURSOR, 0));
			}

		} catch (Exception exe) {
			logger.error("Exception occurred in getInputs:", exe);
		}

		return inputs;
	}

}
